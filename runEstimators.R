source("estimatorFunctions.R")

driftF <- function(x) {x*(1-x)*(1+x)} #{-x} #drift function for the underlying SDE    
myLambda    <- 5  #true value of lambda - for comparison with the estimates
mySigma<- 1       #true value of sigma - for comparison with the estimates
myH    <- 0.75    #true value of H - for comparison with the estimates

### path to the *.csv files with discretely sampled trajectories (e.g. those generated by "simulateSDEwithRP.nb" file):
filePath="C:/Users/Pavel Kříž/Documents/Clanky/Rosenblatt/Rosenblatt SDE param estimation/simulation/simPathsRSDE"

files = list.files(filePath,full.name = TRUE)


N=51200  #number of intervals for a discretized trajectory (i.e. length of the related vector = N+1)
nFile = 5 #number of simulated trajectories in one input file
nSim = 1000 #total number of simulated trajectories (summed over all files)

### read the data from all files in the folder:
firstRun = TRUE
for (f in files){
  actData = scan(f,sep=",",dec=".")
  if (firstRun) {
    mData = matrix(actData,nrow=nFile,ncol=N+1,byrow=TRUE)
  } else {
    mData = rbind(mData,matrix(actData,nrow=nFile,ncol=N+1,byrow=TRUE))  
    }
  firstRun = FALSE
}

### Distinguish the three models - for the purpose of naming the output files only 
model="rSDE"
#model="rOU"
#model="fbmOU"


### location where the output files should be stored
outPath="C:/Users/Pavel Kříž/Documents/Clanky/Rosenblatt/Rosenblatt SDE param estimation/simulation/figures/"


### plot selected trajectories (each 50th) and save into a *.png file
png(file=paste0(outPath,"trajectories_",model,".png"),
    width = 800, # The width of the plot in inches
    height = 400)

plot(seq(from=0,to=1,length=N+1),mData[1,],type="l",ylim=c(-1.5,1.5),ylab="X",xlab="t")
abline(h=0, col="black")
for (i in seq(from=2, to=nSim, by = 50)) {
  lines(seq(from=0,to=1,length=N+1),mData[i,])
} 
dev.off()



nSteps=2^(9:2)  #list of the number of steps for thinning of the observed data
NList <-N/nSteps 


H.estMtrx <- matrix(NA, nrow = nSim, ncol = length(NList)) #matrix with estimates of H  
S.estMtrx <- matrix(NA, nrow = nSim, ncol = length(NList)) #matrix with estimates of sigma 
L1.estMtrx <- matrix(NA, nrow = nSim, ncol = length(NList)) #matrix with estimates of lambda - with true values of sigma and H, without deceleration
L2.estMtrx <- matrix(NA, nrow = nSim, ncol = length(NList)) #matrix with estimates of lambda - with estimated values of sigma and H, with deceleration


### calculate the estimates of (possibly thinned) trajectories
for (j in 1:length(NList)){
  myN<-NList[j]
  timesN<-seq(from=1,to=N,by=nSteps[j])
  for (i in 1:nSim)  {
    trajectory <-mData[i,timesN]
    HS<-estimateHSigma(trajectory)
    H.estMtrx[i,j]<-HS[1]
    S.estMtrx[i,j]<-HS[2]
    L1.estMtrx[i,j]<-estimateLambda(trajectory,sigma=mySigma,H=myH,delta=1,driftFction=driftF)
    L2.estMtrx[i,j]<-estimateLambda(trajectory,sigma=HS[2],H=HS[1],delta=0.5,driftFction=driftF)
  }
}



### generate boxplots of estimates of sigma, H, L1=lambda with true H and sigma and L2=lambda with estimated H and sigma
### and save each into a *.png file
png(file=paste0(outPath,"boxplotH_",model,".png"),
    width = 600, # The width of the plot in pixels
    height = 300)
boxplot(x = as.list(as.data.frame(H.estMtrx)),names=NList,xlab="N",main="Estimates of H")
abline(h=myH, col="red")
dev.off()


png(file=paste0(outPath,"boxplotS_",model,".png"),
    width = 600, # The width of the plot in pixels
    height = 300)
boxplot(x = as.list(as.data.frame(S.estMtrx)),names=NList,xlab="N",main="Estimates of sigma")
abline(h=mySigma, col="red")
dev.off()


png(file=paste0(outPath,"boxplotL1_",model,".png"),
    width = 600, # The width of the plot in pixels
    height = 300)
boxplot(x = as.list(as.data.frame(L1.estMtrx)),ylim=c(-10,20),names=NList,main="Estimates of drift - H and sigma known")
abline(h=myLambda, col="red")
dev.off()


png(file=paste0(outPath,"boxplotL2_",model,".png"),
    width = 600, # The width of the plot in pixels
    height = 300)
boxplot(x = as.list(as.data.frame(L2.estMtrx)),ylim=c(-10,20),names=NList,main="Estimates of drift - H and sigma unknown")
abline(h=myLambda, col="red")
dev.off()



### function for calculating trimmed root mean square error (without outliers)
trimmedRMSE = function(x,trueVal,pBottom,pTop){
  qBottom= quantile(x,pBottom,na.rm=TRUE)
  qTop= quantile(x,pTop,na.rm=TRUE)
  idx = x>qBottom &  x<qTop & !is.na(x)
  xSel = x[idx]
  (mean((xSel-trueVal)^2))^(1/2)
}



### log-log plot of sample RMSE against N of estimates of sigma, H, L1  and L2
### each saved into a *.png file
png(file=paste0(outPath,"rmseH_",model,".png"),
    width = 600, # The width of the plot in pixels
    height = 300)
rmseH<-apply(H.estMtrx,2,function(x){trimmedRMSE(x,myH,0.01,0.99)})
plot(log(NList),log(rmseH),type='l',main="RMSE for H",
     xlab="log(N)", ylab="log(RMSE)")
dev.off()


png(file=paste0(outPath,"rmseS_",model,".png"),
    width = 600, # The width of the plot in pixels
    height = 300)
rmseS<-apply(S.estMtrx,2,function(x){trimmedRMSE(x,mySigma,0.01,0.99)})
plot(log(NList),log(rmseS),type='l',main="RMSE for sigma",
     xlab="log(N)", ylab="log(RMSE)")
dev.off()


png(file=paste0(outPath,"rmseL1_",model,".png"),
    width = 600, # The width of the plot in pixels
    height = 300)
rmseL1<-apply(L1.estMtrx,2,function(x){trimmedRMSE(x,myLambda,0.01,0.99)})
plot(log(NList),log(rmseL1),type='l',main="RMSE for lambda - H and sigma known",
     xlab="log(N)", ylab="log(RMSE)")
dev.off()


png(file=paste0(outPath,"rmseL2_",model,".png"),
    width = 600, # The width of the plot in pixels
    height = 300)
rmseL2<-apply(L2.estMtrx,2,function(x){trimmedRMSE(x,myLambda,0.01,0.99)})
plot(log(NList),log(rmseL2),type='l',main="RMSE for lambda - H and sigma unknown",
     xlab="log(N)", ylab="log(RMSE)")
dev.off()



### generate normal Q-Q plots without outliers (trimmedQQplot) for drift estimators L1 and L2
### and save each into a *.png file
trimmedQQplot = function(x,pBottom,pTop,title){
  qBottom= quantile(x,pBottom,na.rm=TRUE)
  qTop= quantile(x,pTop,na.rm=TRUE)
  idx = x>qBottom &  x<qTop & !is.na(x)
  estimate = x[idx]
  qqnorm(estimate, pch = 1,main=title)
  qqline(estimate, col = "steelblue", lwd = 2)
}


png(file=paste0(outPath,"qqPlotL1_",model,".png"),
    width = 600, # The width of the plot in pixels
    height = 300)
trimmedQQplot(L1.estMtrx[,8],0.001,0.999,"Q-Q plot: lambda estimates - H and sigma known")
dev.off()


png(file=paste0(outPath,"qqPlotL2_",model,".png"),
    width = 600, # The width of the plot in pixels
    height = 300)
trimmedQQplot(L2.estMtrx[,8],0.001,0.999,"Q-Q plot: lambda estimates - H and sigma unknown")
dev.off()



